
class Port:
	def __init__(self, name, direction, msb, lsb, default):
		assert direction in ["in", "out"], "direction for %s must be {in|out}, not %s" % (name, direction)
		assert direction == "in"  or default, "%d needs default" % default
		self.name = name
		self.direction = direction
		self.msb = msb
		self.lsb = lsb
		self.default = default

class Interface:
	def __init__(self, name):
		self.name = name
		self.ports = []
	
	def vhdl_range(self, msb, lsb):
		if msb > lsb:
			return "%d downto %d" % (msb, lsb)
		else:
			return "%d to %d" % (msb, lsb)
	
	def build_vhdl_port(self, port):
		vhdl_type = "std_logic" if port.msb == port.lsb else "std_logic_vector(%s)" % self.vhdl_range(port.msb, port.lsb)
		return "%s : %s %s" % (port.name, port.direction, vhdl_type)
	
	def build_vhdl_component(self, last):
		return "\t\t-- %s\n" % self.name + ';\n'.join("\t\t" + self.build_vhdl_port(x) for x in self.ports) + (not last and ";" or "") + "\n"

	def add_io(self, name, direction, msb, lsb, default = None):
		self.ports.append(Port(name, direction, msb, lsb, default))

def load_interfaces(data):
	current = None
	interfaces = {}
	for line in data.readlines():
		assert line[-1] == '\n', "newline at end, plz"
		line = line.strip()
		if not len(line) or line[0] == '#':
			continue
		if line.find(' ') == -1:
			current = Interface(line)
			interfaces[line] = current
		else:
			ls = line.split(' ')
			assert len(line.split(' ')) in [2, 3], "must be 'direction signal default', is %s" % repr(line)
			direction, signal, default = (ls + [None])[:3]
			msb, lsb = 0, 0
			if signal[-1] == ']':
				pos = signal.index('[')
				assert pos > 0, "bus definition must be Signal[MSB:LSB], is %s" % repr(signal)
				count = signal[pos + 1:-1]
				signal = signal[:pos]
				assert len(count.split(':')) == 2, "bus definition must be Signal[MSB:LSB], is %s" % repr(signal)
				msb, lsb = map(int, count.split(':'))
			current.add_io(signal, direction, msb, lsb, default)
	return interfaces

interfaces = load_interfaces(open("interfaces.txt"))

def build_wrapper(outer, inner):
	outer = outer, outer.split("_")[1:]
	inner = [(i[0], i[0].split("_")[1:], i[1]) for i in inner]
	
	for i in outer[1]:
		assert i in interfaces, "Unknown interface %s in %s" % (i, outer[0])
	for ii in inner:
		for i in ii[1]:
			assert i in interfaces, "Unkown interface %s in %s" % (i, ii[0])

	out  = "\t-- autogenerated by crunchy's wrap.py. DO NOT CHANGE (instead, fix the source and rebuild)\n"
	out += "library IEEE;\n"
	out += "use IEEE.STD_LOGIC_1164.ALL;\n"
	out += "use IEEE.STD_LOGIC_ARITH.ALL;\n"
	out += "use IEEE.STD_LOGIC_UNSIGNED.ALL;\n"

	out += "entity %s is\n" % outer[0]
	out += "Port (\n"
	for i in range(len(outer[1])):
		out += interfaces[outer[1][i]].build_vhdl_component(i == len(outer[1]) - 1)
	out += ");\n"
	
	out += "end %s;\n" % outer[0]
	out += "\n"
	
	out += "architecture wrapper of %s is\n" % outer[0]

	for ii in inner:
		out += "\n"
		out += "component %s\n" % ii[0]

		if ii[2]:
			out += "\tgeneric (\n"
			generics = ii[2].keys()
			for i in range(len(ii[2])):
				out += "\t\t%s: integer%s\n" % (generics[i], i != len(ii[2])-1 and ";" or "")
			out += "\t);\n"

		out += "\tPort (\n"
	
		for i in range(len(ii[1])):
			out += interfaces[ii[1][i]].build_vhdl_component(i == len(ii[1]) - 1)

		out += "\t);\n"
		out += "end component;\n"
	out += "\n"
	out += "begin\n"
	
	interfaces_to_go = outer[1]
	
	for ii in inner:
		out += "%s_inst: %s\n" % (ii[0], ii[0])
		
		if ii[2]:
			out += "\tgeneric map (\n"
			generics = ii[2].keys()
			for i in range(len(ii[2])):
				out += "\t\t%s => %d%s\n" % (generics[i], ii[2][generics[i]], i != len(ii[2])-1 and "," or "")
			out += "\t)\n"

		out += "\tport map (\n"
		for i in range(len(ii[1])):
			assert ii[1][i] in interfaces_to_go, "assume %s to be in %s" % (ii[1][i], interfaces_to_go)
			interfaces_to_go.remove(ii[1][i])
			ports = interfaces[ii[1][i]].ports
			for p in range(len(ports)):
				out += "\t\t%s => %s%s\n" % (ports[p].name, ports[p].name, (p != len(ports)-1 or i != len(ii[1])-1) and "," or "")
		out += "\t);\n"
	
	for ii in interfaces_to_go:
		ports = interfaces[ii].ports
		out += "\n"
		out += "\t-- unused interface %s\n" % ii
		for p in ports:
			if p.default:
				out += "\t%s <= %s;\n" % (p.name, p.default)
	
	out += "end;\n"
	
	return out
